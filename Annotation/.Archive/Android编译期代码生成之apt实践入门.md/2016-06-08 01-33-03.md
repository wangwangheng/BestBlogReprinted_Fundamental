# Android编译期代码生成之apt实践入门
来源:[http://alighters.com/blog/2016/05/10/apt-code-generate/](http://alighters.com/blog/2016/05/10/apt-code-generate/)

现在 Android 主流库中使用 apt 的越来越多，如Dagger2，ButterKnife，DBflow等。不研究一下其怎么玩的，心里实在是不舒服斯基，所以就有了这篇apt代码简单生成的文章。文章的末尾，会附上一些关于注解的基础知识，有兴趣的童鞋可以再去看看。

## Annotation库-定义注解

首先，我们得需要新建一个名称为annotation的Java Library。这里简单的建一个@interfact的注解类即可。如下：

```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
public @interface Test {
    String value();
}
```

可以看到的是，这是编译时期的注解，主要作用于Class。之后，在调用的地方就是需要使用我们的这个注解。

## Compiler库-注解处理器

### 1.使用库引入

这里，也使用的是Java Library，我们把报名定为 compiler，先定义gradle文件：

```
apply plugin: 'java'

sourceCompatibility = 1.7
targetCompatibility = 1.7

dependencies {
    compile 'com.google.auto.service:auto-service:1.0-rc2'
    compile 'com.squareup:javapoet:1.7.0'
    compile project(':annotation')
}
```

代码中，引入两个库，[AutoService](https://github.com/google/auto/blob/master/service%2FREADME.md)主要的作用是注解processor类，并对其生成 META-INF 的配置信息。

[JavaPoet](https://github.com/square/javapoet)这个库的主要作用就是帮助我们通过类调用的形式来生成代码。

### 2. 定义Processor类

建立一个名称为TestProcessor的类，如下

```
@AutoService(Processor.class)
public class TestProcessor extends AbstractProcessor {

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Collections.singleton(Test.class.getCanonicalName());
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        return false;
    }
}
```

其中要注意的是使用`AutoSerivce`的注解，这样就不用再手动配置 META-INF文件了。方法`getSupportedAnnotationTypes`则是定义我们针对生成的注解类，方法`process`则是我们的重头戏，其中则是我们生成代码的主要逻辑之处：

```
@Override
public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
  Set<? extends Element> set = roundEnv.getElementsAnnotatedWith(Test.class);
  for (Element element : set) {
    if (element.getKind() != ElementKind.CLASS) {
      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "only support class");
    }
    MethodSpec main = MethodSpec.methodBuilder("main")
      .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
      .returns(void.class)
      .addParameter(String[].class, "args")
      .addStatement("$T.out.println($S)", System.class, "Hello, JavaPoet!")
      .build();

    TypeSpec helloWorld =
      TypeSpec.classBuilder("HelloWorld").addModifiers(Modifier.PUBLIC, Modifier.FINAL).addMethod(main).build();
    JavaFile javaFile = JavaFile.builder("com.lighters.apt", helloWorld).build();

    try {
      javaFile.writeTo(processingEnv.getFiler());
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
  return false;
}
```



